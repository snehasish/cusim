<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cache Utilisation Simulator: IdealCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>IdealCache Class Reference</h1><!-- doxytag: class="IdealCache" -->
<p>By itself represents a fully associative cache.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="idealcache_8H_source.html">idealcache.H</a>&gt;</code></p>

<p><a href="classIdealCache-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a59fe235bb9edbda5915725e4f11585d4">IdealCache</a> (uint32_t, uint32_t, uint32_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a7b39fbc5408cc9205359019e057333ff">~IdealCache</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor : cleans up the cacheMap in case purge is not called.  <a href="#a7b39fbc5408cc9205359019e057333ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a02411752a823d97cf6684f163e7118bb">access</a> (<a class="el" href="structmemblock.html">memblock</a>, uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Probe set for requested memblock.  <a href="#a02411752a823d97cf6684f163e7118bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#afa1fe5d775c8883f065771ed98275685">print</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print debug information.  <a href="#afa1fe5d775c8883f065771ed98275685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a50cde187a7e9edcaf660aa8a2d88b2a0">setAccessPattern</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *, uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#a50cde187a7e9edcaf660aa8a2d88b2a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#aab9a926dd2da36a78af28acc21355c21">updateAccessPattern</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *, uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#aab9a926dd2da36a78af28acc21355c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#abd648bf612bb963b21a628aad9c0c3c2">purge</a> (uint64_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evict all items from the cache at the end of the simulation run.  <a href="#abd648bf612bb963b21a628aad9c0c3c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a283dca6cf2b5e2d6646a6a2169fd56e9">isFullHit</a> (uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for a full hit, i.e. requested access is present in a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> in the set.  <a href="#a283dca6cf2b5e2d6646a6a2169fd56e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a12e9d286074a061aa2b87de0b76f71c7">isCollatedHit</a> (<a class="el" href="structmemblock.html">memblock</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for a collated hit.  <a href="#a12e9d286074a061aa2b87de0b76f71c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a28b09def6ffbb9a11f1fc428dc3054f7">blockHit</a> (uint64_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the block on Full Hit.  <a href="#a28b09def6ffbb9a11f1fc428dc3054f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a6bb219f8ef746b4214fd73077306f003">loadMemBlock</a> (<a class="el" href="structmemblock.html">memblock</a>, uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load requested memblock into <a class="el" href="classIdealCache.html" title="By itself represents a fully associative cache.">IdealCache</a>, i.e set.  <a href="#a6bb219f8ef746b4214fd73077306f003"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a1598e6b917b30572651a197d0e3ddca6">relocateToHead</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relocates a <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to the top of the LRU Queue.  <a href="#a1598e6b917b30572651a197d0e3ddca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#ade70b69876d409634079d3d7fbea9a5b">pushIntoQueue</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pushes a given block into the LRU Queue.  <a href="#ade70b69876d409634079d3d7fbea9a5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#aefc5444b1afc55f9685cf0f790e854f8">processBlock</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a collated <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>.  <a href="#aefc5444b1afc55f9685cf0f790e854f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a02de3bf5d17cb2f342bf9544aad96416">collatePartial</a> (<a class="el" href="structmemblock.html">memblock</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collate a given memblock.  <a href="#a02de3bf5d17cb2f342bf9544aad96416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#ad3216ccd2421d347b3137d3116b59bb1">deleteFromQueue</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a given block from the LRU Queue.  <a href="#ad3216ccd2421d347b3137d3116b59bb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a80e1ae9b06272a9318264e0d8c1d3723">splitCacheBlock</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *, uint64_t, uint32_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split Cache Block if too large.  <a href="#a80e1ae9b06272a9318264e0d8c1d3723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map&lt; uint64_t, <a class="el" href="structcacheBlock.html">cacheBlock</a> * &gt;<br class="typebreak"/>
::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a2db663325fc68672662ba6a39afcdf76">lowerBound</a> (uint64_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom lower bound function.  <a href="#a2db663325fc68672662ba6a39afcdf76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a26b37e71f46ea399669b62e373e6a9af">evict</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *, uint64_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evict a specific <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>.  <a href="#a26b37e71f46ea399669b62e373e6a9af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a8f08c7c8f94be8a685e63e1e3decad1b">isFullMiss</a> (<a class="el" href="structmemblock.html">memblock</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for Full Miss.  <a href="#a8f08c7c8f94be8a685e63e1e3decad1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a3cd7e04f4fb459f38bb53aa055ac057d">calculateMissBW</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of words required to be brought in from lower level.  <a href="#a3cd7e04f4fb459f38bb53aa055ac057d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#aea06b401ca4d465020a6941685d8f679">getVictim</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to evict.  <a href="#aea06b401ca4d465020a6941685d8f679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#ab3868d9069d3e23be93044ec106b1eb8">updateWordsInCache</a> (<a class="el" href="structcacheBlock.html">cacheBlock</a> *pNewBlock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the word count of the set.  <a href="#ab3868d9069d3e23be93044ec106b1eb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a55f753c2af8d7fd35af14d147b93a29a">getCacheSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the cache in words.  <a href="#a55f753c2af8d7fd35af14d147b93a29a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a46aeafda4c4f827e0b64bade0bdac5d2">isCacheEmpty</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if set is empty.  <a href="#a46aeafda4c4f827e0b64bade0bdac5d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a49e7125cf9d1c1c7a00f0dbc7cba3c1d">getWordsInCache</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current word count.  <a href="#a49e7125cf9d1c1c7a00f0dbc7cba3c1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a9138122a55b354f1e49b2cc6a3330455">getBlockCount</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of blocks in the cache.  <a href="#a9138122a55b354f1e49b2cc6a3330455"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataLogger.html">DataLogger</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a336a104986c6f78cda5cf6a75591d6af">data</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics collector.  <a href="#a336a104986c6f78cda5cf6a75591d6af"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a1c3b99d78a1b5b32532358beb475d27a">cacheSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the set in words.  <a href="#a1c3b99d78a1b5b32532358beb475d27a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a633025a4dcc30736baf16c6535ca828b">wordsInCache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current used words.  <a href="#a633025a4dcc30736baf16c6535ca828b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a392b49e693bc79f98d9c774a63b709e0">maxGran</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max size of a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>; anything larger is split into multiple cacheBlocks.  <a href="#a392b49e693bc79f98d9c774a63b709e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a52e50260ae9c9ae72aa48e43ee9c3312">tagOverhead</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag Overhead per block can be 0 or 1 (representing the number of words) depending on aligned or unaligned access.  <a href="#a52e50260ae9c9ae72aa48e43ee9c3312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#ab9be1b400958c94590d3a4a4fb05c9f5">QHead</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LRU Queue Head pointer.  <a href="#ab9be1b400958c94590d3a4a4fb05c9f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#a13d86b7038f54ecef2d9ffda9bf90772">QTail</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LRU Queue Tail pointer.  <a href="#a13d86b7038f54ecef2d9ffda9bf90772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map&lt; uint64_t, <a class="el" href="structcacheBlock.html">cacheBlock</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIdealCache.html#ac1b407714533a3259c064dd3a325fb7f">cacheMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cachemap for quick lookup of cacheBlocks.  <a href="#ac1b407714533a3259c064dd3a325fb7f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>By itself represents a fully associative cache. </p>
<p>The <a class="el" href="classIdealCache.html" title="By itself represents a fully associative cache.">IdealCache</a> class by itself represents a fully associative cache. Many such objects can be made to simulate a set based cache model. Each <a class="el" href="classIdealCache.html" title="By itself represents a fully associative cache.">IdealCache</a> can operate in aligned mode or in flexible mode. In aligned mode it is only provided with fixed size blocks to load and work with from the <a class="el" href="classCacheController.html" title="Cache with single / multiple sets.">CacheController</a> and <a class="el" href="classPredictor.html">Predictor</a>. This simulates a traditional cache memory system. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a59fe235bb9edbda5915725e4f11585d4"></a><!-- doxytag: member="IdealCache::IdealCache" ref="a59fe235bb9edbda5915725e4f11585d4" args="(uint32_t, uint32_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IdealCache::IdealCache </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>cS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cS</em>&nbsp;</td><td>Set Size in words </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mG</em>&nbsp;</td><td>Maximum Granularity of each <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b39fbc5408cc9205359019e057333ff"></a><!-- doxytag: member="IdealCache::~IdealCache" ref="a7b39fbc5408cc9205359019e057333ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IdealCache::~IdealCache </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor : cleans up the cacheMap in case purge is not called. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a02411752a823d97cf6684f163e7118bb"></a><!-- doxytag: member="IdealCache::access" ref="a02411752a823d97cf6684f163e7118bb" args="(memblock, uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IdealCache::access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemblock.html">memblock</a>&nbsp;</td>
          <td class="paramname"> <em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>memoryAccessSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Probe set for requested memblock. </p>
<p>When the access method of the set, i.e the <a class="el" href="classIdealCache.html" title="By itself represents a fully associative cache.">IdealCache</a> is called, it checks for one of the following scenarios with respect to the requested memblock:</p>
<ul>
<li>Collated Hit : All words are present in the set but in different cacheBlocks</li>
<li>Full Hit : All words are present and in a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a></li>
<li>Full Miss : No words are present in the set</li>
<li>Partial Hit / Miss : Some words are present, others need to be loaded <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb</em>&nbsp;</td><td>Requested memblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>effectiveAddress</em>&nbsp;</td><td>Word aligned start address of actual load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryAccessSize</em>&nbsp;</td><td>Size of access in Bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Latency of the operation(s) performed </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a28b09def6ffbb9a11f1fc428dc3054f7"></a><!-- doxytag: member="IdealCache::blockHit" ref="a28b09def6ffbb9a11f1fc428dc3054f7" args="(uint64_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a> * IdealCache::blockHit </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the block on Full Hit. </p>
<p>In the case of the full hit, this method is used to get a pointer to the block which wholly contains the requested access. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>effectiveAddress</em>&nbsp;</td><td>Word aligned start address of the current access </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> which contains the current access </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd7e04f4fb459f38bb53aa055ac057d"></a><!-- doxytag: member="IdealCache::calculateMissBW" ref="a3cd7e04f4fb459f38bb53aa055ac057d" args="(cacheBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IdealCache::calculateMissBW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pNewBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the number of words required to be brought in from lower level. </p>
<p>This method calculates the number of words to be brought in from the lower level for each miss request. It is to be noted that the miss request can be a partial miss or a complete miss. We assume that it is possible for us to fetch non-contigous blocks for the lower level in a single request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNewBlock</em>&nbsp;</td><td>The <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> being brought into the set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of words required from the lower level </dd></dl>

</div>
</div>
<a class="anchor" id="a02de3bf5d17cb2f342bf9544aad96416"></a><!-- doxytag: member="IdealCache::collatePartial" ref="a02de3bf5d17cb2f342bf9544aad96416" args="(memblock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a> * IdealCache::collatePartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemblock.html">memblock</a>&nbsp;</td>
          <td class="paramname"> <em>mb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collate a given memblock. </p>
<p>Given a memblock, this method creates a new <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> while absorbing existing overlapping cacheBlocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb</em>&nbsp;</td><td>Requested memblock to collate into <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to collated <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3216ccd2421d347b3137d3116b59bb1"></a><!-- doxytag: member="IdealCache::deleteFromQueue" ref="ad3216ccd2421d347b3137d3116b59bb1" args="(cacheBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::deleteFromQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pOldBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a given block from the LRU Queue. </p>
<p>Given a pointer of a <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>, this method removes the block from the LRU Queue and updates the other members of the queue. It also updates the words in cache counter and de-allocates the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOldBlock</em>&nbsp;</td><td>Pointer to <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to remove from LRU Queue and delete </td></tr>
  </table>
  </dd>
</dl>

<p><p>Deleting the only block from the LRU Queue </p>
</p>

</div>
</div>
<a class="anchor" id="a26b37e71f46ea399669b62e373e6a9af"></a><!-- doxytag: member="IdealCache::evict" ref="a26b37e71f46ea399669b62e373e6a9af" args="(cacheBlock *, uint64_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IdealCache::evict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pEvictBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>insCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evict a specific <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>. </p>
<p>This method evicts a specific <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> from the set. The data collection methods are called before the contents are removed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pEvictBlock</em>&nbsp;</td><td>The <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to be evicted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>insCount</em>&nbsp;</td><td>The instruction count at the time of eviction </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if set in not empty, FALSE otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9138122a55b354f1e49b2cc6a3330455"></a><!-- doxytag: member="IdealCache::getBlockCount" ref="a9138122a55b354f1e49b2cc6a3330455" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IdealCache::getBlockCount </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of blocks in the cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of blocks in the set </dd></dl>

</div>
</div>
<a class="anchor" id="a55f753c2af8d7fd35af14d147b93a29a"></a><!-- doxytag: member="IdealCache::getCacheSize" ref="a55f753c2af8d7fd35af14d147b93a29a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IdealCache::getCacheSize </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the cache in words. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size in words </dd></dl>

</div>
</div>
<a class="anchor" id="aea06b401ca4d465020a6941685d8f679"></a><!-- doxytag: member="IdealCache::getVictim" ref="aea06b401ca4d465020a6941685d8f679" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a>* IdealCache::getVictim </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to evict. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to be evicted </dd></dl>

</div>
</div>
<a class="anchor" id="a49e7125cf9d1c1c7a00f0dbc7cba3c1d"></a><!-- doxytag: member="IdealCache::getWordsInCache" ref="a49e7125cf9d1c1c7a00f0dbc7cba3c1d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IdealCache::getWordsInCache </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current word count. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Numer of words in cache </dd></dl>

</div>
</div>
<a class="anchor" id="a46aeafda4c4f827e0b64bade0bdac5d2"></a><!-- doxytag: member="IdealCache::isCacheEmpty" ref="a46aeafda4c4f827e0b64bade0bdac5d2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IdealCache::isCacheEmpty </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if set is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if set is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a12e9d286074a061aa2b87de0b76f71c7"></a><!-- doxytag: member="IdealCache::isCollatedHit" ref="a12e9d286074a061aa2b87de0b76f71c7" args="(memblock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a> * IdealCache::isCollatedHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemblock.html">memblock</a>&nbsp;</td>
          <td class="paramname"> <em>mb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for a collated hit. </p>
<p>A collated hit occurs when all the words requested by the predictor (specified in the memblock) is present in the set, but are not present in a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>. This method checks for a collated hit and if it finds such a case, collates teh blocks and returns a pointer to the new collated block </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb</em>&nbsp;</td><td>Requested memblock </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to collated block if there is a collated hit, NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a283dca6cf2b5e2d6646a6a2169fd56e9"></a><!-- doxytag: member="IdealCache::isFullHit" ref="a283dca6cf2b5e2d6646a6a2169fd56e9" args="(uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IdealCache::isFullHit </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>memoryAccessSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for a full hit, i.e. requested access is present in a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> in the set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>effectiveAddress</em>&nbsp;</td><td>Word aligned start address of the current access </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryAccessSize</em>&nbsp;</td><td>Memory access size in Bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if Full hit, FALSE otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8f08c7c8f94be8a685e63e1e3decad1b"></a><!-- doxytag: member="IdealCache::isFullMiss" ref="a8f08c7c8f94be8a685e63e1e3decad1b" args="(memblock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IdealCache::isFullMiss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemblock.html">memblock</a>&nbsp;</td>
          <td class="paramname"> <em>mb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for Full Miss. </p>
<p>Checks whether a Full Miss occurs for the given memblock; i.e none of the words in the memblock are present in the cache </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb</em>&nbsp;</td><td>The memblock to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if none of the words in the memblock are present in the set </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb219f8ef746b4214fd73077306f003"></a><!-- doxytag: member="IdealCache::loadMemBlock" ref="a6bb219f8ef746b4214fd73077306f003" args="(memblock, uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IdealCache::loadMemBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemblock.html">memblock</a>&nbsp;</td>
          <td class="paramname"> <em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>memoryAccessSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load requested memblock into <a class="el" href="classIdealCache.html" title="By itself represents a fully associative cache.">IdealCache</a>, i.e set. </p>
<p>This method is called whenever one of the following occurs:</p>
<ul>
<li>Full Miss</li>
<li>Partial Miss / Hit The memblock is brought into the cache with necessary processing such as:</li>
<li>Updating / Setting the utilizationBitmap</li>
<li>Splitting the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> if it is larger than the maximum granularity <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb</em>&nbsp;</td><td>Requested memblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>effectiveAddress</em>&nbsp;</td><td>Word aligned start address of access </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryAccessSize</em>&nbsp;</td><td>Size of the memory access in Bytes </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a2db663325fc68672662ba6a39afcdf76"></a><!-- doxytag: member="IdealCache::lowerBound" ref="a2db663325fc68672662ba6a39afcdf76" args="(uint64_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; uint64_t, <a class="el" href="structcacheBlock.html">cacheBlock</a> * &gt;::iterator IdealCache::lowerBound </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Custom lower bound function. </p>
<p>A custom lower bound function for maps indexed with the start address of the cacheBlocks </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The addr to find teh lower bound of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cacheMap Iterator to the lower bound </dd></dl>

</div>
</div>
<a class="anchor" id="afa1fe5d775c8883f065771ed98275685"></a><!-- doxytag: member="IdealCache::print" ref="afa1fe5d775c8883f065771ed98275685" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::print </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print debug information. </p>
<p>Prints out the contents of the LRU Queue of this set </p>

</div>
</div>
<a class="anchor" id="aefc5444b1afc55f9685cf0f790e854f8"></a><!-- doxytag: member="IdealCache::processBlock" ref="aefc5444b1afc55f9685cf0f790e854f8" args="(cacheBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::processBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>collateBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a collated <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>. </p>
<p>Once the bounds of the new <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> have been determined by collatePartial and the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> is allocated, this method absorbs the overlapping blocks into the collated block by:</p>
<ul>
<li>Copying the utilizationBitmap of the absorbed block into the new collated block</li>
<li>Erasing the absorbed block from the LRU Queue and the cacheMap Several Cases &lt;diagram&gt; <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collateBlock</em>&nbsp;</td><td>Pointer to <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> which is to be processed </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="abd648bf612bb963b21a628aad9c0c3c2"></a><!-- doxytag: member="IdealCache::purge" ref="abd648bf612bb963b21a628aad9c0c3c2" args="(uint64_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::purge </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>insCount</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evict all items from the cache at the end of the simulation run. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>insCount</em>&nbsp;</td><td>Latest instruction seen by the set / cachecontroller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade70b69876d409634079d3d7fbea9a5b"></a><!-- doxytag: member="IdealCache::pushIntoQueue" ref="ade70b69876d409634079d3d7fbea9a5b" args="(cacheBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::pushIntoQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pLoadBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pushes a given block into the LRU Queue. </p>
<p>This method pushes a given <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> into the top of the LRU Queue and also updates the words in the cache counter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLoadBlock</em>&nbsp;</td><td>Pointer to <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to be pushed into the LRU Queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1598e6b917b30572651a197d0e3ddca6"></a><!-- doxytag: member="IdealCache::relocateToHead" ref="a1598e6b917b30572651a197d0e3ddca6" args="(cacheBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::relocateToHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>relocateBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relocates a <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to the top of the LRU Queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relocateBlock</em>&nbsp;</td><td>Pointer to the <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to relocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50cde187a7e9edcaf660aa8a2d88b2a0"></a><!-- doxytag: member="IdealCache::setAccessPattern" ref="a50cde187a7e9edcaf660aa8a2d88b2a0" args="(cacheBlock *, uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::setAccessPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pNewBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>memoryAccessSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated. </p>

</div>
</div>
<a class="anchor" id="a80e1ae9b06272a9318264e0d8c1d3723"></a><!-- doxytag: member="IdealCache::splitCacheBlock" ref="a80e1ae9b06272a9318264e0d8c1d3723" args="(cacheBlock *, uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IdealCache::splitCacheBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split Cache Block if too large. </p>
<p>The <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> is checked to see if it needs to be split into smaller blocks. It needs to be split if it is greater than the maximum granularity set by the command line argument to the idealsim simulator. The split blocks are the pushed back into the queue in proper order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBlock</em>&nbsp;</td><td>Pointer to <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> to be split </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>effectiveAddress</em>&nbsp;</td><td>Word aligned start address of the current access </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The maximum allowed granularity / size of a <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the block was split, FALSE otherwise </dd></dl>

<p><p>1. break it into pieces - store in vector 2. if effectiveAddress in range push_back else insert forward 3. delete original block from queue and cachemap 4. insert chunks into queue and cachemap </p>
</p>

</div>
</div>
<a class="anchor" id="aab9a926dd2da36a78af28acc21355c21"></a><!-- doxytag: member="IdealCache::updateAccessPattern" ref="aab9a926dd2da36a78af28acc21355c21" args="(cacheBlock *, uint64_t, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::updateAccessPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pNewBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>effectiveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>memoryAccessSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated. </p>

</div>
</div>
<a class="anchor" id="ab3868d9069d3e23be93044ec106b1eb8"></a><!-- doxytag: member="IdealCache::updateWordsInCache" ref="ab3868d9069d3e23be93044ec106b1eb8" args="(cacheBlock *pNewBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IdealCache::updateWordsInCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcacheBlock.html">cacheBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>pNewBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment the word count of the set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNewBlock</em>&nbsp;</td><td>The block being inserted into the set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac1b407714533a3259c064dd3a325fb7f"></a><!-- doxytag: member="IdealCache::cacheMap" ref="ac1b407714533a3259c064dd3a325fb7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; uint64_t, <a class="el" href="structcacheBlock.html">cacheBlock</a>* &gt; <a class="el" href="classIdealCache.html#ac1b407714533a3259c064dd3a325fb7f">IdealCache::cacheMap</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cachemap for quick lookup of cacheBlocks. </p>

</div>
</div>
<a class="anchor" id="a1c3b99d78a1b5b32532358beb475d27a"></a><!-- doxytag: member="IdealCache::cacheSize" ref="a1c3b99d78a1b5b32532358beb475d27a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classIdealCache.html#a1c3b99d78a1b5b32532358beb475d27a">IdealCache::cacheSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of the set in words. </p>

</div>
</div>
<a class="anchor" id="a336a104986c6f78cda5cf6a75591d6af"></a><!-- doxytag: member="IdealCache::data" ref="a336a104986c6f78cda5cf6a75591d6af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataLogger.html">DataLogger</a> <a class="el" href="classIdealCache.html#a336a104986c6f78cda5cf6a75591d6af">IdealCache::data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statistics collector. </p>

</div>
</div>
<a class="anchor" id="a392b49e693bc79f98d9c774a63b709e0"></a><!-- doxytag: member="IdealCache::maxGran" ref="a392b49e693bc79f98d9c774a63b709e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classIdealCache.html#a392b49e693bc79f98d9c774a63b709e0">IdealCache::maxGran</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max size of a single <a class="el" href="structcacheBlock.html" title="Basic data structure used in the LRU Queue.">cacheBlock</a>; anything larger is split into multiple cacheBlocks. </p>

</div>
</div>
<a class="anchor" id="ab9be1b400958c94590d3a4a4fb05c9f5"></a><!-- doxytag: member="IdealCache::QHead" ref="ab9be1b400958c94590d3a4a4fb05c9f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a>* <a class="el" href="classIdealCache.html#ab9be1b400958c94590d3a4a4fb05c9f5">IdealCache::QHead</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LRU Queue Head pointer. </p>

</div>
</div>
<a class="anchor" id="a13d86b7038f54ecef2d9ffda9bf90772"></a><!-- doxytag: member="IdealCache::QTail" ref="a13d86b7038f54ecef2d9ffda9bf90772" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcacheBlock.html">cacheBlock</a>* <a class="el" href="classIdealCache.html#a13d86b7038f54ecef2d9ffda9bf90772">IdealCache::QTail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LRU Queue Tail pointer. </p>

</div>
</div>
<a class="anchor" id="a52e50260ae9c9ae72aa48e43ee9c3312"></a><!-- doxytag: member="IdealCache::tagOverhead" ref="a52e50260ae9c9ae72aa48e43ee9c3312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classIdealCache.html#a52e50260ae9c9ae72aa48e43ee9c3312">IdealCache::tagOverhead</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tag Overhead per block can be 0 or 1 (representing the number of words) depending on aligned or unaligned access. </p>

</div>
</div>
<a class="anchor" id="a633025a4dcc30736baf16c6535ca828b"></a><!-- doxytag: member="IdealCache::wordsInCache" ref="a633025a4dcc30736baf16c6535ca828b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classIdealCache.html#a633025a4dcc30736baf16c6535ca828b">IdealCache::wordsInCache</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current used words. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Feb 8 18:42:07 2013 for Cache Utilisation Simulator by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
